
//  RNAudioManager.m
//  RNAudioManager
//
//  Created by Vk on 16/3/8.
//  Copyright © 2016年 vk. All rights reserved.
//

#import "RNAudioManager.h"



#define FILE_URL(filename)  [NSURL URLWithString:[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:filename]]

@interface RNAudioManager()
{
    AVAudioRecorder * recordManager ;
    AVAudioPlayer *playerManager ;
    RCTResponseSenderBlock callback;
}
@end

@implementation RNAudioManager

RCT_EXPORT_MODULE();


-(instancetype)init
{
    self = [super init];
    if(self)
    {

    }
    return self;
}

#pragma mark 录音 相关

/**
    录音并写入到文件中，文件默认在Document中
    @param filename

 */
RCT_EXPORT_METHOD(startRecord:(NSString*) filename)
{
    [self recordAtFile:filename];
}



RCT_EXPORT_METHOD(pauseRecord)
{
    [self pauseRecorder];
}


RCT_EXPORT_METHOD(resumeRecord)
{
    [self resumeRecorder];
}

RCT_EXPORT_METHOD(stopRecord)
{
    [self stopRecorder];
}

-(void) setupRecorderWithName:(NSString*) filename
{
    
    AVAudioSession *session = [AVAudioSession sharedInstance];
    [session setCategory:AVAudioSessionCategoryRecord error:nil];
    [session setActive:YES error:nil];
    
    NSError *error ;
    NSMutableDictionary* recordSetting = [[NSMutableDictionary alloc] init];

    [recordSetting setValue :[NSNumber numberWithInt:kAudioFormatLinearPCM] forKey:AVFormatIDKey];
    [recordSetting setValue:[NSNumber numberWithFloat:44100.0f] forKey:AVSampleRateKey];//采样率
    [recordSetting setValue:[NSNumber numberWithInt:16] forKey:AVLinearPCMBitDepthKey];//采样位数
    [recordSetting setValue:[NSNumber numberWithInt:2] forKey:AVNumberOfChannelsKey];//通道数目
    [recordSetting setValue:[NSNumber numberWithBool:NO] forKey:AVLinearPCMIsBigEndianKey];//通道数目
    [recordSetting setValue:[NSNumber numberWithBool:NO] forKey:AVLinearPCMIsFloatKey];//采样信号是整数还是浮点数

    recordManager = [[AVAudioRecorder alloc] initWithURL:FILE_URL(filename) settings:recordSetting error:&error];
    recordManager.delegate = self;
    recordManager.meteringEnabled=YES;//如果要监控声波则必须设置为YES
}


-(void) recordAtFile:(NSString*) filename
{
    [self setupRecorderWithName:filename];
    [recordManager prepareToRecord];

    [recordManager record];

}

-(void) recordAtFile:(NSString*) filename forDuration:(NSTimeInterval)duration
{
    [self setupRecorderWithName:filename];

    [recordManager prepareToRecord];

    [recordManager recordForDuration:duration];
}


-(void) recordAtFile:(NSString*) filename atTime:(NSTimeInterval)time
{
    [self setupRecorderWithName:filename];

    [recordManager prepareToRecord];

    [recordManager recordAtTime:time];
}

-(void) recordAtFile:(NSString*) filename atTime:(NSTimeInterval)time forDuration:(NSTimeInterval)duration
{
    [self setupRecorderWithName:filename];

    [recordManager prepareToRecord];

    [recordManager recordAtTime:time forDuration:duration];
}

-(void) pauseRecorder
{
    if([recordManager isRecording])
    {
        [recordManager pause];
    }
}

-(void) resumeRecorder
{
    if([recordManager currentTime] > 0)
    {
        [recordManager record];
    }
}


-(void) stopRecorder
{
    [recordManager stop];
}

-(BOOL) isRecording
{
    return [recordManager isRecording];
}

-(NSTimeInterval) currentRecordTime
{
    return [recordManager currentTime];
}


#pragma mark 播放 相关




RCT_EXPORT_METHOD(startPlayAtFile:(NSString*) filename)
{
    [self playAtFile:filename];
}

RCT_EXPORT_METHOD(seekPlayToTime:(NSTimeInterval) time)
{
    [self seekTo:time];
}

RCT_EXPORT_METHOD(pausePlay)
{
    [self pausePlayer];
}
RCT_EXPORT_METHOD(resumePlay)
{
    [self resumePlayer];
}


RCT_EXPORT_METHOD(stopPlay)
{
    [self stopPlayer];
}




-(void) playAtFile:(NSString*) filename
{
    AVAudioSession *session = [AVAudioSession sharedInstance];
    [session setCategory:AVAudioSessionCategoryPlayback error:nil];
    [session setActive:YES error:nil];
    NSError *error ;
    playerManager = [[AVAudioPlayer alloc] initWithContentsOfURL:FILE_URL(filename) error:&error];
    playerManager.volume = 1 ;
    [playerManager prepareToPlay];
    [playerManager play];
}

/**
    跳转到指定的时间
 */
-(void) seekTo:(NSTimeInterval) time
{
    NSTimeInterval duration = playerManager.duration ;
    playerManager.currentTime = time > duration ?duration :time < 0 ? 0 :time ;
}

-(void) pausePlayer
{
    if([playerManager isPlaying])
    {
        [playerManager pause];
    }
}

-(void) resumePlayer
{
    if(![playerManager isPlaying])
    {
        [playerManager play];
    }
}

-(void) stopPlayer
{
    [playerManager stop];
}

-(BOOL) isPlaying
{
    return [playerManager isPlaying];
}

-(NSTimeInterval) currentPlayTime
{
    return [playerManager currentTime] ;
}





#pragma mark AVAudioRecorderDelegate
/* audioRecorderDidFinishRecording:successfully: is called when a recording has been finished or stopped. This method is NOT called if the recorder is stopped due to an interruption. */
- (void)audioRecorderDidFinishRecording:(AVAudioRecorder *)recorder successfully:(BOOL)flag
{
    //当阻断的时候，此方法不会被调用
//    UInt32 doChangeDefaultRoute = 1;
//    AudioSessionSetProperty(kAudioSessionProperty_OverrideCategoryDefaultToSpeaker,sizeof(doChangeDefaultRoute), &doChangeDefaultRoute);
}

/* if an error occurs while encoding it will be reported to the delegate. */
- (void)audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)recorder error:(NSError *)error
{
}

#pragma mark AVAudioPlayerDelegate
/* audioPlayerDidFinishPlaying:successfully: is called when a sound has finished playing. This method is NOT called if the player is stopped due to an interruption. */
- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag
{
    //当阻断的时候，此方法不会调用

}

/* if an error occurs while decoding it will be reported to the delegate. */
- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError *)error
{
}




@end
